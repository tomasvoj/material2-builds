{"version":3,"file":"chip-list.js","sourceRoot":"","sources":["../../../../src/lib/chips/chip-list.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  AfterContentInit,\n  ChangeDetectionStrategy,\n  Component,\n  ContentChildren,\n  ElementRef,\n  QueryList,\n  Renderer,\n  ViewEncapsulation\n} from '@angular/core';\n\nimport {MdChip} from './chip';\nimport {FocusKeyManager} from '../core/a11y/focus-key-manager';\nimport {\n  LEFT_ARROW, RIGHT_ARROW, BACKSPACE, DELETE, UP_ARROW, DOWN_ARROW\n} from '../core/keyboard/keycodes';\nimport {Dir} from '../core/rtl/dir';\n\n/**\n * A material design chips component (named ChipList for it's similarity to the List component).\n *\n * Example:\n *\n *     <md-chip-list>\n *       <md-chip>Chip 1<md-chip>\n *       <md-chip>Chip 2<md-chip>\n *     </md-chip-list>\n */\n@Component({\n  moduleId: module.id,\n  selector: 'md-chip-list, mat-chip-list',\n  template: `<div class=\"mat-chip-list-wrapper\"><ng-content></ng-content></div>`,\n  host: {\n    'role': 'listbox',\n    '[class.mat-chip-list]': 'true',\n\n    '[attr.tabindex]': '_tabIndex',\n\n    '(focus)': 'focus($event)',\n    '(keydown)': '_keydown($event)'\n  },\n  queries: {\n    chips: new ContentChildren(MdChip)\n  },\n  styleUrls: ['chips.css'],\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class MdChipList implements AfterContentInit {\n\n  /** When a chip is destroyed, we track the index so we can focus the appropriate next chip. */\n  protected _destroyedIndex: number = null;\n\n  /** Track which chips we're listening to for focus/destruction. */\n  protected _subscribed: WeakMap<MdChip, boolean> = new WeakMap();\n\n  /** Holds our current input if provided. */\n  protected _inputElement: HTMLInputElement;\n\n  /** Whether or not the chip list is currently focusable via keyboard interaction. */\n  _tabIndex = -1;\n\n  /** The FocusKeyManager which handles focus. */\n  _keyManager: FocusKeyManager;\n\n  /** The chip components contained within this chip list. */\n  chips: QueryList<MdChip>;\n\n  constructor(protected _renderer: Renderer, protected _elementRef: ElementRef,\n              protected _dir: Dir) {\n  }\n\n  ngAfterContentInit(): void {\n    this._keyManager = new FocusKeyManager(this.chips).withWrap();\n\n    // Go ahead and subscribe all of the initial chips\n    this._subscribeChips(this.chips);\n\n    // Make sure we set our tab index at the start\n    this._checkTabIndex();\n\n    // When the list changes, re-subscribe\n    this.chips.changes.subscribe((chips: QueryList<MdChip>) => {\n      this._subscribeChips(chips);\n\n      // If we have 0 chips, attempt to focus an input (if available)\n      if (chips.length == 0) {\n        this.focusInput();\n      }\n\n      // Check to see if we need to update our tab index\n      this._checkTabIndex();\n\n      // Check to see if we have a destroyed chip and need to refocus\n      this._checkDestroyedFocus();\n    });\n  }\n\n  /**\n   * Associates an HTML input element with this chip list.\n   *\n   * @param inputElement The input to associate.\n   */\n  registerInput(inputElement: HTMLInputElement) {\n    this._inputElement = inputElement;\n  }\n\n  /**\n   * Programmatically focus the chip list. This in turn focuses the first non-disabled chip in this\n   * chip list, or the input if available and there are 0 chips.\n   *\n   * TODO: ARIA says this should focus the first `selected` chip if any are selected.\n   */\n  focus(event?: Event) {\n    if (this.chips.length > 0) {\n      this._keyManager.setFirstItemActive();\n    } else {\n      this.focusInput();\n    }\n  }\n\n  /** Attempt to focus an input if we have one. */\n  focusInput() {\n    if (this._inputElement) {\n      this._inputElement.focus();\n    }\n  }\n\n  /**\n   * Pass events to the keyboard manager. Available here for tests.\n   */\n  _keydown(event: KeyboardEvent) {\n    let code = event.keyCode;\n    let target = event.target as HTMLElement;\n    let isInputEmpty = MdChipList._isInputEmpty(target);\n    let isRtl = this._dir.value == 'rtl';\n\n    let isPrevKey = (code == (isRtl ? RIGHT_ARROW : LEFT_ARROW));\n    let isNextKey = (code == (isRtl ? LEFT_ARROW : RIGHT_ARROW));\n    let isBackKey = (code == BACKSPACE || code == DELETE || code == UP_ARROW || isPrevKey);\n    let isForwardKey = (code == DOWN_ARROW || isNextKey);\n\n    // If they are on an empty input and hit backspace/delete/left arrow, focus the last chip\n    if (isInputEmpty && isBackKey) {\n      this._keyManager.setLastItemActive();\n      event.preventDefault();\n      return;\n    }\n\n    // If they are on an empty input and hit the right arrow, wrap focus to the first chip\n    if (isInputEmpty && isForwardKey) {\n      this._keyManager.setFirstItemActive();\n      event.preventDefault();\n      return;\n    }\n\n    // If they are on a chip, check for space/left/right, otherwise pass to our key manager (like\n    // up/down keys)\n    if (target && target.classList.contains('mat-chip')) {\n      if (isPrevKey) {\n        this._keyManager.setPreviousItemActive();\n        event.preventDefault();\n      } else if (isNextKey) {\n        this._keyManager.setNextItemActive();\n        event.preventDefault();\n      } else {\n        this._keyManager.onKeydown(event);\n      }\n    }\n  }\n\n  /**\n   * Iterate through the list of chips and add them to our list of\n   * subscribed chips.\n   *\n   * @param chips The list of chips to be subscribed.\n   */\n  protected _subscribeChips(chips: QueryList < MdChip >): void {\n    chips.forEach(chip => this._addChip(chip));\n  }\n\n  /**\n   * Check the tab index as you should not be allowed to focus an empty list.\n   */\n  protected _checkTabIndex(): void {\n    // If we have 0 chips, we should not allow keyboard focus\n    this._tabIndex = (this.chips.length == 0 ? -1 : 0);\n  }\n\n  /**\n   * Add a specific chip to our subscribed list. If the chip has\n   * already been subscribed, this ensures it is only subscribed\n   * once.\n   *\n   * @param chip The chip to be subscribed (or checked for existing\n   * subscription).\n   */\n  protected _addChip(chip: MdChip) {\n    // If we've already been subscribed to a parent, do nothing\n    if (this._subscribed.has(chip)) {\n      return;\n    }\n\n    // Watch for focus events outside of the keyboard navigation\n    chip.onFocus.subscribe(() => {\n      let chipIndex: number = this.chips.toArray().indexOf(chip);\n\n      if (this._isValidIndex(chipIndex)) {\n        this._keyManager.updateActiveItemIndex(chipIndex);\n      }\n    });\n\n    // On destroy, remove the item from our list, and setup our destroyed focus check\n    chip.destroy.subscribe(() => {\n      let chipIndex: number = this.chips.toArray().indexOf(chip);\n\n      if (this._isValidIndex(chipIndex) && this._keyManager.activeItemIndex == chipIndex) {\n        this._destroyedIndex = chipIndex;\n      }\n\n      this._subscribed.delete(chip);\n      chip.destroy.unsubscribe();\n    });\n\n    this._subscribed.set(chip, true);\n  }\n\n  /**\n   * Checks to see if a focus chip was recently destroyed so that we can refocus the next closest\n   * one.\n   */\n  protected _checkDestroyedFocus() {\n    let chipsArray = this.chips.toArray();\n    let focusChip: MdChip;\n\n    if (this._destroyedIndex != null && chipsArray.length > 0) {\n      // Check whether the destroyed chip was the last item\n      if (this._destroyedIndex >= chipsArray.length) {\n        this._keyManager.setActiveItem(chipsArray.length - 1);\n      } else if (this._destroyedIndex >= 0) {\n        this._keyManager.setActiveItem(this._destroyedIndex);\n      }\n\n      // Focus the chip\n      if (focusChip) {\n        focusChip.focus();\n      }\n    }\n\n    // Reset our destroyed index\n    this._destroyedIndex = null;\n  }\n\n  /**\n   * Utility to ensure all indexes are valid.\n   *\n   * @param index The index to be checked.\n   * @returns True if the index is valid for our list of chips.\n   */\n  private _isValidIndex(index: number): boolean {\n    return index >= 0 && index < this.chips.length;\n  }\n\n  /** Utility to check if an input element has no value. */\n  private static _isInputEmpty(element: HTMLElement): boolean {\n    if (element && element.nodeName.toLowerCase() == 'input') {\n      let input = element as HTMLInputElement;\n\n      return input.value == '' || input.value == null;\n    }\n\n    return false;\n  }\n}\n"]}